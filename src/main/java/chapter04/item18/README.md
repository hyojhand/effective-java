# 아이템18. 상속보다는 컴포지션을 사용하라

상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다.

상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전하다.  
또한, 확장할 목적으로 설계되었고 문서화도 잘 된 클래스(item 19)도 안전하다.

하지만, **일반적인 구체 클래스를 패키지 경계를 넘어, 다른 패키지의 구체 클래스를 상속하는(클래스가 다른 클래스를 확장하는) ‘구현 상속’은 위험하다.**

**메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.**  
즉, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.  
ex) HashSet을 상속하여 add, addAll 재정의 시 예상한대로 동작하지 않는다.

### 상속으로 하위 클래스가 깨지기 쉬운 이유

1. 자신의 다른 부분을 사용하는 ‘자기사용(self-use)’ 여부는 해당 클래스의 내부 구현 방식에 해당하며, 다음 릴리스에서도 유지될지는 알 수 없다.
2. 상위 클래스의 메서드 동작을 다른식으로 재정의하여 다시 구현하는 방식은 어렵고, 시간도 더 들고, 자칫 오류를 내거나 성능을 떨어뜨릴 수 있다.
3. 다음 릴리스에서 상위 클래스에 새로운 메서드를 추가한다면 어떤 문제가 생길지 모른다.

### 상속보다는 컴포지션을 활용하라

**기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하자!**  
기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 **컴포지션(composition: 구성**)이라 한다.

새 클래스의 private 필드를 참조하는 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.  
이 방식을 전달(forwarding)이라 하며, 전달 메서드(forwarding method)라고 한다.

결과적으로, **새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새로운 메서드가 추가되어도 전혀 영향을 받지 않는다.**

### 상속은 반드시 하위 클래스가 상위 클래스의 ‘진짜’ 하위 타입인 상황에서만 쓰여야 한다.

클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.  
상속을 사용하기 전에 ”B가 정말 A인가?”, ”확장하려는 클래스의 API에 아무런 결함이 없는가? 있다면 결함이 클래스의 API까지 전파돼도 괜찮은가?” 라고 자문해보자!

컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 것이다.

그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다. 또한, 클라이언트가 노출된 내부에 직접 접근할 수 있게 된다.
클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다.