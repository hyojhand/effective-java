# 아이템15. 클래스와 멤버의 접근 권한을 최소화하라

**캡슐화를 통해 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리하자!**

클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는가?
오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않아야 한다.

## 1. 캡슐화의 장점

- 시스템 개발 속도를 높인다. (여러 컴포넌트를 병렬로 개발할 수 있다)
- 시스템 관리 비용을 낮춘다. (컴포넌트를 빨리 파악하여 디버깅하고, 다른 컴포넌트로 교체하는 부담도 적다)
- 소프트웨어 재사용성을 높인다. (외부에 의존하지 않는 독자적으로 동작하는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다)
- 큰 시스템을 제작하는 난이도를 낮춰준다. (시스템 전체 완성 이전에 개별 컴포넌트의 동작을 검증할 수 있다)
- 성능 최적화에 도움을 준다. (캡슐화 자체가 성능에 도움을 주진 않지만, 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음(item 67), 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다)

## 2. 클래스와 인터페이스의 접근 제한자 사용 원칙

- 캡슐화의 핵심 원칙은 **“모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다”** 이다.
- 톱 레벨 클래스와 인터페이스에 package-private 또는 public을 쓸 수 있다.
    - public은 공개되어 API가 되므로, 하위 호완성을 유지하려면 영원히 관리해야한다.
    - package-private은 패키지 외부에서 쓰지 않을 클래스나 인터페이스에 사용한다.
- 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는, 이를 사용하는 클래스 안에 private static으로 중첩시키면, 바깥 클래스 하나에서만 접근할 수 있다.

### private static 중첩 (item 24)

private static으로 중첩시켜, 바깥 클래스 하나에서만 접근하도록 한다.

&#42; **private이 아닌 private static 의 이유는??**  
private 클래스는 자신을 사용하는 외부 클래스의 필드를 마음껏 사용할 수 있으므로 참조하는 관계가 된다.
하지만, private static 클래스는 inner 클래스이지만 static이기에 해당 클래스와 관련이 없는 독립적인 관계이다. 감싸는 쪽에서만 사용하는 일방적인 관계로 만들 수 있다.

## 3. 멤버(필드, 메서드, 중첩 클래스/인터페이스)의 접근 제한자 원칙

private, package-private은 내부 구현, public 클래스의 protected, public은 공개 API이다.

먼저, public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁힌다.  
클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만들자!
그런 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어준다.

하지만, 리스코프 치환 원칙(상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다)을 지키기 위해, 상위 클래스의 메서드를 재정의할 대는 그 접근 수준을 상위 클래스보다 좁게 설정할 수 없다.

### 단지 테스트의 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓혀야 하는가?

public 클래스의 private 멤버를 package-private 정도의 적당한 수준까지는 괜찮다.  
하지만, 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다!  
테스트 코드를 테스트 대상과 같은 패키지에 두면 package-private 요소에 접근할 수 있다!

### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. (item 16)

필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public 으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. 그 필드와 관련된 모든 것을 불변식으로 보장할 수 없게 된다.

즉, public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
→ 멀티 스레드 환경에서 어떤 스레드가 값을 어떻게 바꿀지 알 수 없기 때문에 thread-safe 하지 않다.

하지만, 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소의 상수라면, public static final 필드로 공개하고 상수 이름은 대문자 알파벳, 단어사이에 밑줄을 넣는 관례를 따른다. (item 68)

public static 같은 상수 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다. (item 17)

단, 길이가 0이 아닌 배열은 모두 변경 가능하니, 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다!

Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.(item 86,87)
→ private, package-private 이라도 역직렬화 할 때 변하면 안되기 때문

## 자바 플랫폼 모듈 시스템 (Java Platform Module System, JPMS) - 자바 9 모듈

패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음이다.

JSR-376  스펙으로 정의한 자바 모듈 시스템으로 더 나은 컴포넌트간의 관계를 표현할 수 있는 방법을 제공한다.

- 안정성 - 순환 참조를 허용하지 않는다. 실행시 필요한 모듈을 확인한다. 한 패키지는 한 모듈에서만 공개할 수 있다.
- 캡슐화 - public 인터페이스나 클래스라도 공개된 패키지만 사용할 수 있어, 내부 구현을 보호하는 수단으로 사용할 수 있다.
- 확장성 - 필요한 자바 플랫폼 모듈만 모아서 최적의 JRE를 구성할 수 있다. 작은 기기에서 구동할 어플리케이션을 개발할 때 유용하다.

protected 혹은 public 멤버라도 해당 패키지를 공개(export)하지 않으면 모듈 외부에서는 접근할 수 없다. 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다. module-info에서 exports를 통해 외부로 공개하고, 사용하는 모듈에서 requires로 사용할 모듈을 지정하면 사용할 수 있게 된다.

하지만, 모듈의 JAR 파일을 자신의 모듈 경로가 아닌 어플리케이션의 클래스패스(classpath)에 두면, 그 모듈 안의 모든 패키지는 마치 모듈이 없는 것처럼 행동한다. 즉, 모듈이 공개했는지 여부와 상관없이, public 클래스가 선언한 모든 public 혹은 protected 멤버를 모듈 밖에서도 접근할 수 있게 된다.

모듈의 장점을 제대로 누리려면 해야할 일이 많기 때문에, 꼭 필요한 경우가 아니면 잘 사용하지 않는다.