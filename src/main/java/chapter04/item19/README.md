# 아이템19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

메서드를 재정의해서 사용할 때 어떤 순서로 호출되고, 어떤 결과가 영향을 주는지 담아야 한다.

API 문서의 메서드 설명에서 **Implementation Requirements**로 시작하는 절이 메서드 내부 동작 방식을 설명하는 곳이다.  
메서드 주석에 **@implSpec** 태그를 붙이면 자바독 도구가 생성해준다.

[좋은 API 문서란 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다.] 라는 격언과 상충된다.

### 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 ‘유일’하다.

클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

그러니 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 빈자리가 확연히 드러난다.  
반대로, 전혀 쓰이지 않는 protected 멤버는 private이어야 할 가능성이 크다.

### 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 기능 메서드를 호출해서는 안된다.

상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 이때, 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화되는 값에 의존한다면 의도와 다르게 동작한다.

### clone, readObject 모두 직접적으로든 간접적으로든 재정의 기능 메서드를 호출해서는 안된다.

readObject 메서드는 미처 다 역직렬화되기 전에 재정의한 메서드가 호출되거나, 하위 클래스의 clone 메서드가 복제된 상태를 수정하기 전에 재정의한 메서드를 호출하는 문제가 생긴다.

Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다. private으로 선언하면 하위 클래스에서 무시된다.

## 상속용으로 설계하지 않은 클래스는 상속을 금지하자!

1. 클래스를 final로 선언하여 상속을 금지
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어 상속을 금지