# 아이템37. ordinal 인덱싱 대신 EnumMap을 사용하라

열거 타입이 몇 번째 위치인지를 반환하는 ordinal() 메서드를 사용해 인덱스를 얻고, 이 인덱스로 배열에 값을 넣는데 사용하지 말자

1. 배열은 제네릭과 호환되지 않으니(item 28) 비검사 형변환을 수행해야 하고 깔끔히 컴파일되지 않을 것이다.
2. 배열은 각 인덱스의 의미를 모르니 출력 결과에 직접 레이블을 달아야 한다.
3. 열거 타입과 달리 type safe하지 않기 때문에, 정확한 정수값을 사용한다는 것을 직접 보증해야 한다.

### 열거타입을 key로 사용하도록 설계한 EnumMap을 사용하자

더 짧고 명료하고 안전하다. Map의 key인 열거 타입이 그 자체로 출력용 문자열을 제공하니 출력 결과에 직접 레이블을 달 필요도 없다.
또한, 내부에서 배열을 사용하는 내부 구현 방식을 안으로 숨겨서 Map의 타입 안전성과 배열의 성능을 모두 얻을 수 있다.

스트림의 `Collectors.groupingBy` 메서드를 사용해 Map,EnumMap을 관리하면 코드를 더 줄일 수 있다.

**두 열거 타입 값들을 매핑하는 상황에서도 ordinal을 사용해서 배열로 관리하지 말자**

컴파일러는 ordinal과 배열 인덱스의 관계를 알 수 없다. 함께 수정하지 않으면 ArrayIndexOutOfBoundsException이나 NullPointerException이 발생하며 이상하게 동작할 수 있다. 또한, 불필요한 배열 공간이 null로 채워지게 된다.

→ EnumMap을 사용해서 안쪽 Map은 key값으로 하나의 열거 타입 값을 사용하고, value로 다른 열거 타입 값을 가진다. 바깥 Map은 key값으로 하나의 열거 타입 값을 가져 EnumMap<Enum1, EnumMap<Enum1, Enum2>> 형태로 관리할 수 있다.

**배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, EnumMap을 사용하라**