# 아이템10. equals는 일반 규약을 지켜 재정의하라

필요가 없다면, equals를 재정의 하지 않는 것이 최선이다!

### equals를 재정의 하지 않아도 되는 경우

- **각 인스턴스가 본질적으로 고유한 경우**

싱글턴 패턴이나 enum 클래스는 그 인스턴스가 하나이기 때문에 equals 재정의는 필요없다.

- **인스턴스의 ‘논리적 동치성’을 검사할 일이 없는 경우**

10달러 2개는 같은걸까?  
→ 값이 같냐 : 논리적 동치성 / 물체가 같냐 : 다른 물체이기 때문에 다르다

기본적으로 Object의 equals는 객체의 동일성을 비교한다.  
따라서, 논리적 동치성을 검사할 일이 없다면, equals 재정의는 필요없다. ex) 문자열

- **상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는 경우**
- **클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없는 경우**

public 클래스는 어떻게 쓰일지 예측하기 어렵기 때문에 private이나 package-private에서는 equals를 호출할 일이 없다.

### equals를 재정의 해야 하는 경우

두 객체가 물리적으로 같은가(객체 식별성)가 아닌 “**논리적 동치성**”을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때다. ex) 값 클래스(Integer, String)

값 클래스라고 해도, **값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스(정적 팩터리 메서드)이거나 Enum 이라면 equals를 재정의 하지 않아도 된다.**

### equals 규약

- **반사성 : A.equals(A) == true**
- **대칭성 : A.equals(B) == B.equals(A)**
- **추이성 : A.equals(B) && B.equals(C), A.equals(C)**  
  Point, ColorPoint(inherit), CounterPointer, ColorPoint(comp)
- **일관성 : A.equals(B) == A.equals(B)**
- **null이 아님 : A.equals(null) == false**

**equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.**

**구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다!!  
→ 상속 대신 컴포지션을 활용하라! (item18)**

**불변 객체는 일관성이 같다. 클래스를 작성할 때는 불변 클래스로 만드는게 나을지를 심사숙고 하자! (item17)**

**클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.**

### equals 메서드 구현 방법

1. **== 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.**
2. **instanceof 연산자로 입력이 올바른 타입인지 확인한다.**
3. **입력을 올바른 타입으로 형변환한다.**
4. **입력 객체와 자기 자신의 대응되는 ‘핵심’ 필드들이 모두 일치하는지 하나씩 검사한다.**

### equals 주의사항

- **equals를 재정의 할 때는 hashCode도 반드시 재정의하자(item 11)**
- **너무 복잡하게 해결하지 말자**
- **Object가 아닌 타입의 매개변수를 받는 equals 메서드는 선언하지 말자**  
  → 입력 타입이 Object가 아니므로, Object.equals 메서드를 재정의한 것이 아니다. “다중 정의” 한 것이다.