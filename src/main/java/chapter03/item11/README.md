# 아이템11. equals를 재정의하려거든 hashCode도 재정의하라

**equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.**

그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

### hashCode 규약

equals에서 사용했던 필드(핵심 필드)를 모두 사용해야 한다.  
또한, equals 메서드에 사용되지 않은 필드는 반드시 제외해야 한다.

- equals 비교에 사용되는 정보가 변경되지 않았다면, 어플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 어플리케이션을 다시 실행하면 값이 달라져도 된다.
- **equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.  
  → 논리적으로 같은 객체는 같은 hashCode를 반환해야 한다.**
- equals가 두 객체를 다르다고 판단했다면, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.  
  → **좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.**
  
**HashMap의 동작 과정 - 해시 충돌**

hashCode 값을 구해서, 해시테이블의 버킷에 넣어준다. 즉, 객체가 다르지만 hashCode가 같다면 버킷 하나에 담겨 마치 연결 리스트(Linked List)처럼 동작한다.O(n)으로 느려져서 성능이 느려진다.

### hashCode 구현 방법 - 좋은 해시 함수

**hashCode 구현 방법 1.**

1. 핵심 필드의 hashCode를 구한다.
2. 나머지 핵심 필드 각각의 해시코드를 계산한다.
3. 계산한 해시코드로 결과를 갱신한다. (31 * result + hashCode)  
 \* 홀수이면서 소수이기 때문에 곱하는 숫자를 31로 사용

**hashCode 구현 방법 2.**

Object.hashCode() 사용 - 내부적으로 방법 1로 작동한다.  
하지만, 입력 인수를 담기 위한 배열이 만들어지고, boxing, unboxing 등으로 성능이 조금 더 안좋다.

**hashCode 구현 방법 3.**

클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하지 않고 캐싱하는 방식이다.

hashCode가 처음 불릴 때 계산하는 지연 초기화(lazy initialization) 전략  
→ 단, 필드를 지연 초기화 하려면 그 클래스를 스레드 안전하게 만들도록 신경 써야 한다. (item 83)