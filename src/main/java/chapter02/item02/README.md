# 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라

정적 팩터리와 생성자에서 선택전 매개변수가 많아지면 적절히 대응하기 어렵다.

### **1. 점층적 생성자 패턴 (생성자 체이닝)**

필수적인 매개변수는 생성자에 포함하여 객체를 생성할때 강제할 수 있게 하는게 좋다.
나머지 원하는 매개변수를 모두 포함한 생성자를 늘리는데, 매개변수가 작은 생성자부터 늘리면서 **생성자 체이닝**을 통해 줄일 수 있다.

→ 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. 매개변수의 순서가 바껴도 컴파일러는 알아채지 못하고, 런타임에 잘못된 동작을 하게된다.

### **2. 자바빈즈 패턴**

getter, setter를 정의해놓은 Java 표준 스펙 중의 하나이다.

매개변수가 없는 생성자로 객체를 만든 후, setter 메서드들을 호출해 원하는 매개변수의 값을 설정한다.

하지만, 매개변수가 없는 생성자로 객체를 만들기 때문에 객체 생성이 굉장히 간단하지만,  
필수 필드값들이 없는 상태로 객체가 생성되기 때문에, **객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다!** 어느 값까지 세팅해주어야 일관성이 무너지지 않은 객체가 되는지는 알 수가 없다.

### **점층적 생성자 패턴 + 자바빈즈 패턴**

필수적인 필드는 매개변수를 통해 생성자로 넘겨받아 강제성을 부여해서 일관성이 무너지는 문제를 해결하고,  
나머지 필드는 자바빈즈 패턴의 setter를 사용해 값을 설정할 수도 있겠다.

- 하지만, 여전히 존재하는 문제로는 **불변객체로 만들기 어렵다!**
- setter를 통해 값을 설정하기 때문에 한번 설정된 값이 변경될 수 있다.
- Java에는 없는 객체 프리징이라는 기술을 사용해볼 수도 있겠다. 하지만 거의 사용하지 않는 방법이다.

## 빌더 패턴

동일한 프로세스를 거쳐 다양한 구성의 인스턴스를 만드는 방법으로,  복잡한 객체를 만드는 프로세스를 독립적인 클래스로 분리할 수 있다.

- 플루먼트 API 또는 메서드 체이닝을 한다.
- 계층적으로 설계된 클래스와 함께 사용하기 좋다.
- 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈 보다 훨씬 안전하다.

자바빈즈 패턴의 setter 반환값이 void인 반면에, setter와 동일한 기능을 하는 값을 넣어주는 메서드의 반환값은 Builder이다. 이를 통해 메서드 체이닝이 가능해진다.

최종적으로 build() 메서드로 객체를 만들어 준다.

Build 인스턴스를 생성할때, 필수 속성에 해당하는 것을 설정하여 강제할 수 있어서 자바빈즈 패턴보다 훨씬 안전하게 객체를 생성할 수 있다.

결과적으로 생성자 체이닝 + 자바빈즈 패턴의 장점을 얻을 수 있다.

하지만, 무조건 빌더패턴을 사용하는 것이 아닌, **필수적인 필드와 선택적인 필드가 있을때 이로인한 메서드가 많아지며, 불변 객체를 만들고 싶을때 빌더 패턴을 고려하자!**

 \* 어노테이션 프로세서 - 어노테이션 자체로는 아무 기능이 없지만, 컴파일하는 시점에 어노테이션을 읽어서 코드를 조작할 수 있는 기능을 부여한다.

### lombok의 @Builder 어노테이션 문제점

lombok의 @Builder로 인해 모든 파라미터를 받는 생성자가 생기는데, 이로인해 매개변수가 많은 생성자가 외부로 노출될 뿐만 아니라, Builder와 생성자 둘다 존재하게 된다.

이러한 생성자를 허용하고 싶지 않을 경우 @AllArgsConstructor 어노테이션으로 Accesslevel을 private으로 설정해준다. 이로인해 외부에서는 Builder만 사용하여 객체를 생성할 수 있게 한다.

하지만 @Builder에서는 필수 매개변수를 설정하게 만들기가 어렵다.

## 계층형 빌더 패턴 (핵심)

계층의 클래스에서 Builder 클래스가 재귀적 타입 한정을 이용하는 재귀적 타입일때,  
**this를 리턴해서 Builder 자기 자신의 타입을 리턴한다면, Builder를 사용할때 본인 클래스의 Builder의 메서드만 사용가능하다! 
하위 클래스에서 사용하기 위해서는 빌더 타입을 casting 해주어야 한다.**

따라서, 하위 빌더의 메서드를 쓰려면 하위 클래스의 빌더를 리턴해주어야 하므로, self()메서드로 하위 클래스 타입의 Builder를 리턴하여 사용한다.

이렇게 **하위 클래스의 메서드가 상위 크래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(covariant return typing)** 이라 한다. 
이 기능을 이용하면 **클라이언트가 형변환에 신경쓰지 않고도 빌더를 사용**할 수 있다.

예제) Pizza, NyPizza, Calzone

<br/>

## 자바빈(JavaBean)이란?

(주로 GUI에서) 재사용 가능한 소프트웨어 컴포넌트로 java.beans 패키지 안에 있는 모든 것

- 자바빈이 지켜야할 규약
    - getter와 setter 메서드 이름 규약 (boolean은 isMethod())
    - argument 없는 기본 생성자 / why? 객체를 만들기 편하기 때문에
    - Serializable 인터페이스 구현 / why? 객체를 직렬화해서 다시 재사용할 수 있게

하지만 완벽하게 JavaBean 규약을 따를 필요는 없다!

JPA나 Spring 같은 여러 프레임워크에서 리플렉션을 통해 특정 객체의 값을 조회하거나 설정하기 때문에 오늘날 자바빈 스펙 중에서도 getter와 setter가 주로 쓰인다.

**\* Java17의 Java record에 대해 알아보자**

## 객체 얼리기 (freezing)

>JS에서 임의의 객체를 불변 객체로 만들어주는 기능으로 Object.freeze()에 전달한 객체는 그뒤로 변경될 수 없다. strict 모드에서만 동작한다.

- 새 프로퍼티를 추가하지 못함
- 기존 프로퍼티를 제거하지 못하고, 프로퍼티 값을 변경하지 못함
- 프로토 타입을 변경하지 못함

Java에서 비슷하게 동작하게하려면 값을 변경하는 setter에서 해당 객체가 freeze 상태인지 확인하는 메서드가 필요하겠다. 하지만, 객체를 생성해서 쓰다가 중간에 얼리고, 불변으로 바꾼 이후 계속 체크하는 것은 굉장히 어지럽다.

## IllegalArgumentException

잘못된 인자를 넘겨 받았을 때 사용할 수 있는 기본 런타임 예외

예외를 던질때 어떤 Argument가 잘못되었는지 또는 이유를 생성자에 넣어 던지는게 좋다.

**질문1) checked exception 과 unchecked exception의 차이?**  
→ checked exception은 다시 checked exception을 던지거나, try-catch로 예외 처리해야한다.  
복구가 가능한 상황에 checked exception을 던진다. (트랜잭션과 예외는 아무 상관이 없다)

**질문2) 간혹 메서드 선언부에 unchecked exception을 선언하는 이유는?**  
→ 선언하지 않아도 되지만, 클라이언트에게 명시적으로 알려주고 싶을때 선언한다.  
너무 많은 unchecked exception이 발생하면 모두 선언하기 어렵기때문에, checked exception만 선언한다.

**질문3) checked exception은 왜 사용할까?**  
→ 에러가 발생했을때, 후속 작업을 강요하는 경우 checked exception을 사용한다.  
메서드를 호출하는 사람은 메서드가 throw 할 수 있는 예외에 대해 알고 있어야 그에 대해 수행할 작업을 결정할 수 있다.

* 자바의 모든 RuntimeException 클래스 이름 읽어보기

> [https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)  
>If a client can reasonably be expected to recover from an exception, make it a checked exception.   
>If a client cannot do anything to recover from the exception, make it an unchecked exception.

클라이언트가 예외를 복구할 것으로 예상되면, checked exception을 사용하고, 클라이언트가 예외 복구를 위해 아무것도 할 수 없으면, unchecked exception으로 생성한다.

## 가변인수

>**빌더를 이용하면 가변인수(varargs) 매개변수를 여러개 사용할 수 있다. 각각을 적절한 메서드로 나눠 선언하면 된다.**

여러 인자를 받을 수 있는 가변적인 argument (Var + args)

- 가변인수는 메서드에 오직 하나만 선언할 수 있다.
- 가변인수는 메서드의 가장 마지막 매개변수가 되어야 한다.

가변인수가 여러개 필요하면 각 Builder의 메서드마다 여러개를 선언하여 사용할 수 있다.