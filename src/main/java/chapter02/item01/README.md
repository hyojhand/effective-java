# 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라

클라이언트가 클래스의 인스턴스를 얻을 때 생성자가 아닌 정적 팩터리 메서드 (static factory method)를 제공할 수 있다.

## 정적 팩터리 메서드가 public 생성자보다 좋은 장점

### 1. 이름을 가질 수 있다.

생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지못한다.  
하지만, 정적 팩터리 메서드는 이름만 잘 지으면 반환될 객체의 특성을 이름으로 잘 묘사할 수 있다.

ex) BigInteger(int,int, Random) vs BigInteger.probablePrime  
둘중 어디가 ‘값이 소수인 BigInteger를 반환한다’는 의미가 더 와닿는가?

하나의 시그니처로 생성자는 하나만 만들 수 있다.  
매개변수의 순서를 다르게 하여 생성자를 추가할 수 있지만, 각 생성자가 어떤 역할을 하는지 정확히 기억하기 어렵고, 코드를 읽는 사람도 의미를 알지 못한다!

하지만, 정적 팩터리 메서드는 이러한 제약이 없다.  
**하나의 시그니처로 명확한 역할을 나타내는 생성자를 만들 수 있다.**


### 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식의 불필요한 객체 생성을 피할 수 있다. 이렇게 하면, 같은 객체(특히 생성비용이 큰 객체)가 자주 요청될때 성능을 상당히 올려준다.

ex) Boolean.valueOf(boolean)에서 매개변수 boolean에 따라 TRUE,FALSE 인스턴스를 반환한다.  
이처럼 매개변수에 따라 각기 다른 인스턴스를 반환할 수 있다.

**정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아있게 할지를 철저히 통제할 수 있는 인스턴스 통제 클래스(instance-controlled)이다.**

**인스턴스 통제의 장점**

1. 싱글턴(item 3)으로 만들수도, 인스턴스화 불가(item 4)로 만들 수 있다.
2. 불변 값 클래스(item 17)에서 동치인 인스턴스가 단 하나 뿐임을 보장할 수 있다. ( a == b 일때만 a.equals(b) 성립 )

인스턴스 통제는  플라이웨이트 패턴의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.

### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다

메서드의 리턴 타입에는 인터페이스지만, return 해주는 인스턴스는 해당 인터페이스의 구현체를 반환할 수 있다.  
또는, 클래스를 선언해놓고 해당 클래스의 하위 클래스를 반환할 수 있다.

이는 **반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 "엄청난 유연성"을 준다.**

메서드를 호출하여 가져오는 타입이 인터페이스가 된다. 이는 클라이언트로 부터 인터페이스 기반의 프레임워크를 사용하도록 강제할 수 있으며, 구체적인 타입도 숨길 수 있다.

\* Java8 이후부터는 인터페이스에 정적 메서드를 선언할 수 있다.  
→ 인터페이스에 정적 메서드를 선언하여, 정적 팩터리 메서드를 가지고 있는 클래스를 많이 만들지 않아도 된다.  
하지만, Java8에서 인터페이스는 public 정적 멤버만 허용하기 때문에, 별도의 package-private 클래스가 필요할 수 있다.

Java9 에서는 private 정적 메서드까지 허락하지만, 정적 필드와 정적 멤버 클래스는 여전히 public 이어야 한다.

### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다

반환 타입의 하위타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.

ex) EnumSet 클래스  
원소가 64개 이하면 long 변수 하나로 관리하는 RegularEnumSet, 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.

**클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수도 없고 알 필요도 없다!**  
하위 클래스이기만 하면 된다.

### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다

인터페이스에 구현체가 없을때, ServiceLoader 라는 Java에서 기본으로 제공하는 정적 팩터리 메서드로 해당 인터페이스의 모든 구현체를 가져온다.

ServiceLoader : service provider 프레임워크의 Java 기본 구현체

**어떤 구현체가 올지 모르지만, 임의의 구현체에 의존적이지 않고 사용할 수 있다!**

## 단점

### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다

정적 팩터리만을 제공하기 위해 생성자를 private으로 설정하면, 클래스를 상속할 수 없다!

이를 public으로 변경해 생성자를 이용하거나 팩터리 메서드 둘다 사용할 수 있다.  
ex) List의 생성자로 생성, 정적팩터리 메서드 of()

불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.

### 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다

API 명세서에 명확히 드러나는 생성자와 달리 생성자를 제공하지 않고 정적 팩터리 메서드만 있다면, 클래스를 인스턴스화할 방법을 알아내야 한다.

가장 좋은 방법은 **문서화**를 하는 것이다!  
- javadoc 생성 - mvc javadoc:javadoc
- javadoc 확인 - target/site/index.html 을 open in

**흔히 사용하는 명명 방식**

- **from** : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드  
  ex) Date d = Date.from(instant);
- **of** : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드  
  ex) Set<Rank> faceCards = EnumSet.of(JACK,QUEEN,KING);
- **valueOf** : from과 of의 더 자세한 버전  
  ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);


- **instance** 혹은 **getInstance** : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, **같은 인스턴스임을 보장하지는 않는다.**  
  ex) StackWalker luke = StackWalker.getInstance(options);
- **create** 혹은 **newInstance** : instance 혹은 getInstance와 같지만, **매번 새로운 인스턴스를 생성해 반환함을 보장**한다.  
  ex) Object newArray = Array.newInstance(classObject, arrayLen);


- **getType** : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리메서드를 정의할 때 쓴다.  
“Type”은 팩토리 메서드가 반환할 객체의 타입이다.  
ex) FileStore fs = Files.getFileStore(path)
- **newType** : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 쓴다.  
”Type”은 팩토리 메서드가 반환할 객체의 타입이다.  
ex) BufferedReader br = Files.newBufferedReader(path);
- **type** : getType 과 newType의 간결한 버전  
  ex) List<Complaint> litany = Collections.list(legachLitany);

### 결론

정적 팩토리메서드와 public 생성자의 장단점을 이해하고 올바르게 사용하자  
하지만, 정적 팩토리메서드를 사용하는 것이 유리한 경우가 많으므로, 무작정 public 생성자를 제공하는 습관을 고치자!

<br/>

## ❗️ 열거타입 (Enumeration)

>**열거타입은 인스턴스가 하나만 만들어짐을 보장한다.**

필드가 가질 수 있는 값을 특정한 값으로 제한할 수 있다. (type-safed, 타입 안정성)  
오로지 인스턴스가 하나만 만들어진다.

질문1. enum 클래스가 가질 수 있는 모든 타입을 순회하면서 출력하라  
→ **enum타입.values()** : enum 클래스의 모든 타입을 반환한다

질문2. enum은 Java의 클래스처럼 생성자, 메서드, 필드를 가질 수 있는가?  
→ enum 내부적으로 필드나 메서드를 가질 수 있다.

질문3. enum의 값은 == 연산자로 동일성을 비교할 수 있는가?  
→ JVM 레벨에서 오로지 하나의 인스턴스만을 보장하기 때문에 ‘==’을 권장한다.  
또한, **equals()는 NullPointerException이 발생할 수 있다.**

추가) enum을 key로 사용하는 Map을 정의하세요. 또는 enum을 담고 있는 Set을 만들어 보세요  
→ **EnumMap**, **EnumSet** 활용, 그 이유는??

## ❗️ 플라이웨이트 패턴 (Flyweight pattern)

>**같은 객체가 자주 사용되는 상황에 플라이웨이트 패턴을 사용할 수 있다.** 

→ 매번 새로운 객체를 생성하지 않고, 어딘가에 저장해두고 재사용하거나 캐싱하는게 좋겠다.

**플라이웨이트 패턴이란?**
- 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴
- 자주 변하는 속성(또는 외적인 속성, extrinsit)과 변하지 않는 속성(또는 내적인 속성, intrinsit)을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.

자주 재사용되지만 자주 변경되지 않는 것을 어딘가 플라이웨이트 팩토리에 모아놓고 꺼내쓰는 형식이다.

## ❗️ 인터페이스에 정적 메서드

>**Java 8 부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에 인스턴스화 불가 동반 클래스를 둘 이유가 없다.**

Java 8과 9에서 주요 인터페이스의 변화

기본 메서드(default method)와 정적 메서드를 가질 수 있다.

- **기본 메서드**

인터페이스에서 메서드 선언 뿐만 아니라, 기본적인 구현체까지 제공할 수 있다.  
기존의 인터페이스를 구현하는 클래스에 새로운 기능을 추가할 수 있다.

- **정적 메서드**

Java 9부터 private static 메서드를 가질 수 있다.  
단, private 필드는 아직 선언할 수 없다.

질문1. 내림차순으로 정렬하는 Comparator를 만들고 List<Integer>를 정렬하라
```java
Comparator<Integer> desc = (o1, o2) -> o2 - o1;
//        Comparator<Integer> desc = new Comparator<Integer>() {
//            @Override
//            public int compare(Integer o1, Integer o2) {
//                return o2 - o1;
//            }
//        };
```

질문2. 질문1에서 만든 Comparator를 사용해서 오름차순으로 정렬하라  
→ Comparator 객체의 기본 메서드로 **reversed()** 사용

## ❗️ 서비스 제공자 프레임워크

>**서비스 제공자 프레임워크를 만드는 근간이 된다.**

확장 가능한 어플리케이션을 만드는 방법 → 코드는 그대로 유지하되 설정이나 외적인 요소로 변경이 가능한

**주요 구성 요소**

- **서비스 제공자 인터페이스(SPI)와 서비스 제공자 (서비스 구현체)**  
  서비스 제공자 인터페이스 : 여러 구현체를 만들어 확장가능하게 만들고 싶은 서비스
- **서비스 제공자 등록 API** : 서비스 인터페이스의 구현체를 등록하는 방법
- **서비스 접근 API** : 서비스의 클라이언트가 서비스 인터페이스의 인스턴스를 가져올 때 사용하는 API

다양한 변형

- 브릿지 패턴 : **구체적인 것과 추상적인 것의 분리가 목적**이다.(서로 독립적인 구조로 발전할 수 있게)
- 의존 객체 주입 프레임워크 (Spring)

## ❗️리플렉션 (reflection)

>**서비스 제공자 인터페이스가 없다면, 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야 한다.**

클래스로더를 통해 읽어온 클래스 정보(거울에 반사된 정보)를 사용하는 기술

리플렉션을 사용해 클래스를 읽어오거나, 인스턴스를 만들거나, 메서드를 실행하거나,  
필드의 값을 가져오거나 변경하는 것이 가능하다.

리플렉션의 사용

- 특정 어노테이션이 붙어있는 필드 또는 메서드 읽어오기 (JUnit, Spring)
- 특정 이름 패턴에 해당하는 메서드 목록 가져와 호출하기 (getter, setter)

```java
// 문자열로 클래스 읽어올 수 있다
Class<?> aClass = Class.forName("chapter02.item01.KoreaHelloService");
// getConstructor로 생성자를 가져와서 newInstance()로 인스턴스를 생성할 수 있다.
Constructor<?> constructor = aClass.getConstructor();
HelloService helloService = (HelloService) constructor.newInstance();

또는
aClass.getDeclaredMethod(), aClass.getDeclaredField()로 메서드나 필드를 참조할 수 있으며,
값을 변경하는 것도 가능하다. 심지어 private 메서드, 필드라도 가능하다!
```

**\* ServiceLoader에 대해 알아보자**